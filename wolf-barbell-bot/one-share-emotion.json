{
  "name": "One-Share Emotional Tracker",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{ "hours": 24 }]
        }
      },
      "id": "daily",
      "name": "Daily Check",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "sheetId": "YOUR_SHEET_ID",
        "range": "One Share Trades!A:F"
      },
      "id": "positions",
      "name": "Get Open Positions",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "=https://api.twelvedata.com/price?symbol={{ $json.Symbol }}&apikey=YOUR_API_KEY",
        "options": {}
      },
      "id": "price",
      "name": "Get Current Price",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "// This node runs once per position row (n8n loops over each Sheets row).\n//\n// Problem with original: used $input.first() and $input.last() â€” positional references\n// that break if node execution order shifts.\n//\n// Fix: use named node + paired item references.\n//   $('Get Open Positions').item  â†’ the Sheets row that triggered this loop iteration\n//   $input.first().json           â†’ the price response from the HTTP node (current item)\n//\n// Requires n8n >= v0.198 for .item paired reference support.\n\nconst priceData = $input.first().json;\nconst pos       = $('Get Open Positions').item.json;\n\n// TwelveData returns price as a string â€” parse defensively\nconst priceRaw = priceData?.price;\nif (!priceRaw) {\n  return [{ json: { ...pos, error: 'Price unavailable from TwelveData', status: 'UNKNOWN' } }];\n}\n\nconst currentPrice = parseFloat(priceRaw);\n\n// Normalise column names â€” handle both camelCase and Title Case from Sheets\nconst symbol     = pos.Symbol     || pos.symbol;\nconst entryPrice = parseFloat(pos['Entry Price'] || pos.entryPrice || '0');\nconst shares     = parseInt(pos.Shares          || pos.shares     || '1', 10);\n\nif (!entryPrice || isNaN(entryPrice)) {\n  return [{ json: { symbol, error: 'Missing or invalid entry price in sheet', status: 'UNKNOWN' } }];\n}\n\nconst pnlDollar = (currentPrice - entryPrice) * shares;\nconst pnlPct    = (pnlDollar / (entryPrice * shares)) * 100;\nconst status    = pnlDollar > 0 ? 'WIN' : pnlDollar < 0 ? 'LOSS' : 'FLAT';\n\nreturn [{\n  json: {\n    symbol,\n    entryPrice,\n    currentPrice,\n    shares,\n    pnlDollar:  pnlDollar.toFixed(2),\n    pnlPct:     pnlPct.toFixed(2),\n    status\n  }\n}];\n",
        "mode": "runOnceForEachItem"
      },
      "id": "calc",
      "name": "Calculate P&L",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "resource": "message",
        "chatId": "YOUR_TELEGRAM_CHAT_ID",
        "text": "=ðŸ§  *One Share Daily Check*\n{{ $json.symbol }}: {{ $json.status }}\nEntry: ${{ $json.entryPrice }} Ã— {{ $json.shares }} share(s)\nNow:   ${{ $json.currentPrice }}\nP&L:   ${{ $json.pnlDollar }} ({{ $json.pnlPct }}%)\n\nHow are you feeling about this position?"
      },
      "id": "telegram",
      "name": "Emotional Check",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [1050, 300]
    }
  ],
  "connections": {
    "Daily Check":         { "main": [[{ "node": "Get Open Positions", "type": "main", "index": 0 }]] },
    "Get Open Positions":  { "main": [[{ "node": "Get Current Price",  "type": "main", "index": 0 }]] },
    "Get Current Price":   { "main": [[{ "node": "Calculate P&L",      "type": "main", "index": 0 }]] },
    "Calculate P&L":       { "main": [[{ "node": "Emotional Check",    "type": "main", "index": 0 }]] }
  }
}
